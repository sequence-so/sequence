import moment from "moment";
import { track, identify } from "src/events";
import SequenceWebhook from "../models/sequenceWebhook.model";
import WebhookExecution from "../models/webhookExecution.model";
import Event from "../models/event.model";
import SequenceError from "src/error/sequenceError";
import logger from "src/utils/logger";
import { HttpResponse } from "src/routes/segment.http";
import { EventPayload } from "sequence-node";

interface WebhookPayload {
  batch: EventPayload[];
}

/**
 * Segment events are saved in the Events table under columns (source, sourceId) = (SEQUENCE_WEBHOOK_ID, webhookExecution.id)
 */
export const SEQUENCE_WEBHOOK_ID = "segment_webhook";

/**
 * Process events coming from Segment.
 */
class SequenceProcessor {
  /**
   * Entry function for this processor.
   *
   * @param webhook SequenceWebhook
   * @param body Event body
   * @returns
   */
  async process(webhook: SequenceWebhook, body: WebhookPayload) {
    let execution: WebhookExecution;
    try {
      execution = await this.logWebhookEvent(webhook, body);
      for (let idx = 0, len = body.batch.length; idx < len; idx++) {
        const elem = body.batch[idx];
        await this.handleEvent(elem, execution);
      }
    } catch (error) {
      logger.error("SegmentProcess.process:" + error.stack);
      throw new SequenceError("An error occured processing the event", 500);
    }
    return {
      success: true,
    };
  }
  /**
   * Logs the execution of webhook.
   *
   * @param webhook SequenceWebhook
   * @param body Request body
   * @returns WebhookExecution
   */
  async logWebhookEvent(
    webhook: SequenceWebhook,
    body: any
  ): Promise<WebhookExecution> {
    await webhook.update({
      execution: webhook.executions + 1,
      lastExecutionAt: new Date(),
    });
    return WebhookExecution.create({
      type: SEQUENCE_WEBHOOK_ID,
      payload: body,
      webhookId: webhook.id,
      userId: webhook.userId,
    });
  }
  /**
   * Processes an event from Segment.
   *
   * @param event A Segment event
   * @param webhook WebhookExecution
   * @returns
   */
  async handleEvent(
    event: EventPayload,
    webhook: WebhookExecution
  ): Promise<HttpResponse> {
    if (!event.messageId) {
      logger.info(
        "SequenceProcessor.handleEvent No messageId receieved, skipping"
      );
      throw new Error("No message ID generated by client");
    }

    const existing = await Event.findOne({
      where: {
        userId: webhook.userId,
        messageId: event.messageId,
      },
    });

    if (existing) {
      logger.info(
        "SequenceProcessor.handleEvent Duplicate messageId receieved, skipping: " +
          event.messageId
      );
      return {
        success: true,
        processed: false,
      };
    }

    if (event.type === "identify") {
      console.log("identifying", event);
      await identify(
        {
          type: "identify",
          traits: event.traits,
          userId: event.userId,
          context: event.context,
          messageId: event.messageId,
          receivedAt: new Date(),
          sentAt: moment(event.sentAt || new Date()).toDate(),
          timestamp: moment(event.timestamp).toDate(),
        },
        {
          userId: webhook.userId,
        }
      );
    } else if (event.type === "track") {
      await track(
        {
          type: "track",
          event: event.event,
          userId: event.userId,
          context: event.context,
          messageId: event.messageId,
          properties: event.properties,
          receivedAt: new Date(),
          sentAt: moment(event.sentAt || new Date()).toDate(),
          timestamp: moment(event.timestamp).toDate(),
        },
        {
          userId: webhook.userId,
          source: webhook.type,
          sourceId: webhook.id,
        }
      );
    }
    return {
      success: true,
      processed: true,
    };
  }
}

export default SequenceProcessor;
